<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Platform Video Streamer</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            margin: 20px; 
            background-color: #f4f4f9; 
            color: #333; 
        }
        .container { 
            max-width: 900px; 
            margin: auto; 
            background: #fff; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
        }
        h1 { text-align: center; color: #444; }
        .stats { 
            display: flex; 
            justify-content: space-around; 
            margin: 20px 0; 
            padding: 15px; 
            background: #e3f2fd; 
            border-radius: 5px; 
        }
        .stat-item { text-align: center; }
        .stat-value { font-size: 24px; font-weight: bold; color: #1976d2; }
        .stat-label { font-size: 12px; color: #666; }
        .input-section { 
            margin-bottom: 20px; 
            padding: 15px; 
            background: #f8f9fa; 
            border: 1px solid #ddd; 
            border-radius: 5px; 
        }
        #magnetInput { 
            width: calc(100% - 24px); 
            padding: 10px; 
            border: 1px solid #ccc; 
            border-radius: 4px; 
            font-family: monospace; 
            font-size: 14px; 
            margin-bottom: 10px;
        }
        video { 
            width: 100%; 
            background: #000; 
            border-radius: 5px; 
            margin-top: 10px; 
            max-height: 500px;
        }
        .actions { 
            display: flex; 
            justify-content: center; 
            margin: 15px 0; 
            gap: 10px; 
            flex-wrap: wrap;
        }
        button { 
            background-color: #007bff; 
            color: white; 
            border: none; 
            padding: 10px 20px; 
            border-radius: 5px; 
            cursor: pointer; 
            font-size: 16px; 
            transition: background-color 0.2s; 
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #6c757d; cursor: not-allowed; }
        button.success { background-color: #28a745; }
        button.danger { background-color: #dc3545; }
        .logs { 
            height: 200px; 
            overflow-y: auto; 
            background: #333; 
            color: #f8f8f8; 
            border: 1px solid #444; 
            padding: 10px; 
            font-family: monospace; 
            font-size: 12px; 
            border-radius: 5px; 
            white-space: pre-wrap; 
            margin-top: 20px;
        }
        .status { 
            padding: 10px; 
            margin: 10px 0; 
            border-radius: 5px; 
            text-align: center; 
            font-weight: bold; 
        }
        .status.connected { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.disconnected { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.loading { background-color: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .stream-info { 
            background: #f1f3f4; 
            padding: 15px; 
            border-radius: 5px; 
            margin: 10px 0; 
            display: none;
        }
        .stream-info.visible { display: block; }
        .api-tests {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .test-result {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
        }
        .test-success { background: #d4edda; color: #155724; }
        .test-error { background: #f8d7da; color: #721c24; }

        /* Add these new styles */
        .network-stats {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }
        .network-item {
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 3px;
        }
        .network-value {
            font-size: 18px;
            font-weight: bold;
            color: #1976d2;
        }
        .network-label {
            font-size: 11px;
            color: #666;
        }
        .buffer-indicator {
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .buffer-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            width: 0%;
            transition: width 0.3s ease;
        }
        .quality-selector {
            margin: 10px 0;
        }
        .quality-btn {
            margin: 2px;
            padding: 5px 10px;
            font-size: 12px;
        }

        .torrent-stats {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }
        .torrent-item {
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 3px;
            border-left: 4px solid #007bff;
        }
        .torrent-value {
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }
        .torrent-label {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
        }
        .health-excellent { border-left-color: #28a745; }
        .health-good { border-left-color: #17a2b8; }
        .health-fair { border-left-color: #ffc107; }
        .health-poor { border-left-color: #fd7e14; }
        .health-critical { border-left-color: #dc3545; }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #0056b3);
            width: 0%;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        .peer-list {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        .peer-item {
            padding: 5px;
            margin: 2px 0;
            background: white;
            border-radius: 3px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Multi-Platform Video Streamer</h1>
        
        <!-- Server Stats -->
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="activeStreams">-</div>
                <div class="stat-label">Active Streams</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="connectedClients">-</div>
                <div class="stat-label">Connected Clients</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="uptime">-</div>
                <div class="stat-label">Uptime (min)</div>
            </div>
        </div>

        <!-- Connection Status -->
        <div id="status" class="status disconnected">Connecting to server...</div>
        
        <!-- API Tests -->
        <div class="api-tests">
            <h3>API Tests</h3>
            <button onclick="testHealthAPI()">Test Health API</button>
            <button onclick="testListStreams()">List All Streams</button>
            <div id="apiResults"></div>
        </div>

        <!-- Stream Controls -->
        <div class="input-section">
            <input type="text" id="magnetInput" placeholder="Enter magnet link" 
                   value="magnet:?xt=urn:btih:dd8255ecdc7ca55fb0bbf81323d87062db1f6d1c&dn=Big+Buck+Bunny">
            <div class="actions">
                <button id="createStreamBtn" onclick="createStream()" disabled>Create Stream</button>
                <button id="destroyStreamBtn" onclick="destroyCurrentStream()" disabled>Destroy Stream</button>
                <button onclick="refreshStats()">Refresh Stats</button>
            </div>
        </div>

        <!-- Stream Info -->
        <div id="streamInfo" class="stream-info">
            <h3>Current Stream</h3>
            <p><strong>Stream ID:</strong> <span id="currentStreamId">-</span></p>
            <p><strong>Status:</strong> <span id="streamStatus">-</span></p>
            <p><strong>Filename:</strong> <span id="streamFilename">-</span></p>
            <p><strong>File Size:</strong> <span id="streamFileSize">-</span></p>
        </div>
        
        <!-- Video Player -->
        <video id="videoPlayer" controls></video>
        
        <!-- Logs -->
        <div class="logs" id="logs"></div>

        <!-- Network Stats -->
        <div class="network-stats">
            <div class="network-item">
                <div class="network-value" id="downloadSpeed">0</div>
                <div class="network-label">Download (KB/s)</div>
            </div>
            <div class="network-item">
                <div class="network-value" id="totalDownloaded">0</div>
                <div class="network-label">Downloaded (MB)</div>
            </div>
            <div class="network-item">
                <div class="network-value" id="bufferHealth">0</div>
                <div class="network-label">Buffer Health (%)</div>
            </div>
            <div class="network-item">
                <div class="network-value" id="networkLatency">0</div>
                <div class="network-label">Latency (ms)</div>
            </div>
            <div class="network-item">
                <div class="network-value" id="connectionType">Unknown</div>
                <div class="network-label">Connection</div>
            </div>
            <div class="network-item">
                <div class="network-value" id="videoState">Idle</div>
                <div class="network-label">Video State</div>
            </div>
        </div>

        <!-- Buffer Indicator -->
        <div class="buffer-indicator">
            <div class="buffer-fill" id="bufferFill"></div>
        </div>

        <!-- Quality Selector -->
        <div class="quality-selector">
            <label>Streaming Quality:</label>
            <button class="quality-btn" onclick="setStreamingQuality('auto')">Auto</button>
            <button class="quality-btn" onclick="setStreamingQuality('fast')">Fast (Lower Quality)</button>
            <button class="quality-btn" onclick="setStreamingQuality('high')">High Quality</button>
        </div>

        <!-- Torrent Monitoring -->
        <div class="torrent-stats" id="torrentStats" style="display: none;">
            <div class="torrent-item">
                <div class="torrent-value" id="torrentPeers">0</div>
                <div class="torrent-label">Total Peers</div>
            </div>
            <div class="torrent-item">
                <div class="torrent-value" id="torrentSeeders">0</div>
                <div class="torrent-label">Seeders</div>
            </div>
            <div class="torrent-item">
                <div class="torrent-value" id="torrentLeechers">0</div>
                <div class="torrent-label">Leechers</div>
            </div>
            <div class="torrent-item" id="torrentHealthItem">
                <div class="torrent-value" id="torrentHealth">Unknown</div>
                <div class="torrent-label">Health</div>
            </div>
            <div class="torrent-item">
                <div class="torrent-value" id="torrentDownSpeed">0</div>
                <div class="torrent-label">Download Speed</div>
            </div>
            <div class="torrent-item">
                <div class="torrent-value" id="torrentUpSpeed">0</div>
                <div class="torrent-label">Upload Speed</div>
            </div>
            <div class="torrent-item">
                <div class="torrent-value" id="torrentProgress">0%</div>
                <div class="torrent-label">Progress</div>
            </div>
            <div class="torrent-item">
                <div class="torrent-value" id="torrentETA">‚àû</div>
                <div class="torrent-label">ETA</div>
            </div>
            <div class="torrent-item">
                <div class="torrent-value" id="torrentRatio">0.0</div>
                <div class="torrent-label">Share Ratio</div>
            </div>
        </div>

        <!-- Progress bar -->
        <div class="progress-bar" id="torrentProgressBar" style="display: none;">
            <div class="progress-fill" id="torrentProgressFill">0%</div>
        </div>
    </div>

    <script>
        // Global state
        let ws;
        let isConnected = false;
        let clientId = null;
        let currentStreamId = null;
        let currentStream = null;
        let pollTimeoutId = null; // Track polling timeout to cancel it

        // DOM elements
        const videoPlayer = document.getElementById('videoPlayer');
        const magnetInput = document.getElementById('magnetInput');
        const logs = document.getElementById('logs');
        const status = document.getElementById('status');
        const createStreamBtn = document.getElementById('createStreamBtn');
        const destroyStreamBtn = document.getElementById('destroyStreamBtn');
        const streamInfo = document.getElementById('streamInfo');

        // Logging function
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : '‚ÑπÔ∏è';
            logs.innerHTML += `[${timestamp}] ${prefix} ${message}\n`;
            logs.scrollTop = logs.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        // Update connection status
        function updateStatus(connected, message = '') {
            isConnected = connected;
            if (connected) {
                status.textContent = message || 'Connected to server';
                status.className = 'status connected';
                createStreamBtn.disabled = false;
            } else {
                status.textContent = message || 'Disconnected from server';
                status.className = 'status disconnected';
                createStreamBtn.disabled = true;
                destroyStreamBtn.disabled = true;
            }
        }

        // API Functions (only for specific calls, not polling)
        async function apiCall(endpoint, options = {}) {
            try {
                const response = await fetch(`/api${endpoint}`, {
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    },
                    ...options
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || `HTTP ${response.status}`);
                }
                
                return data;
            } catch (error) {
                log(`API Error: ${error.message}`, 'error');
                throw error;
            }
        }

        // Test API endpoints
        async function testHealthAPI() {
            try {
                const health = await apiCall('/health');
                document.getElementById('apiResults').innerHTML = 
                    `<div class="test-result test-success">Health API: ${JSON.stringify(health, null, 2)}</div>`;
                log('Health API test successful', 'success');
                updateStats(health.stats);
            } catch (error) {
                document.getElementById('apiResults').innerHTML = 
                    `<div class="test-result test-error">Health API Error: ${error.message}</div>`;
            }
        }

        async function testListStreams() {
            try {
                const streams = await apiCall('/streams');
                document.getElementById('apiResults').innerHTML = 
                    `<div class="test-result test-success">Streams API: ${JSON.stringify(streams, null, 2)}</div>`;
                log(`Found ${streams.total} active streams`, 'success');
            } catch (error) {
                document.getElementById('apiResults').innerHTML = 
                    `<div class="test-result test-error">Streams API Error: ${error.message}</div>`;
            }
        }

        // Stream management via WebSocket
        function createStream() {
            const magnetLink = magnetInput.value.trim();
            if (!magnetLink) {
                log('Please enter a magnet link', 'error');
                return;
            }

            if (!clientId || !isConnected) {
                log('Not connected to server. Please wait.', 'error');
                return;
            }

            try {
                updateStatus(true, 'Creating stream...');
                status.className = 'status loading';
                
                log(`Creating stream for magnet: ${magnetLink.substring(0, 50)}...`);
                
                // Send stream creation request via WebSocket
                ws.send(JSON.stringify({
                    type: 'create_stream',
                    magnetLink: magnetLink,
                    clientId: clientId
                }));

                createStreamBtn.disabled = true;
                
            } catch (error) {
                log(`Failed to send stream creation request: ${error.message}`, 'error');
                updateStatus(true, 'Connected to server');
            }
        }

        async function destroyCurrentStream() {
            if (!currentStreamId) {
                log('No active stream to destroy', 'error');
                return;
            }

            try {
                // Cancel any ongoing polling
                if (pollTimeoutId) {
                    clearTimeout(pollTimeoutId);
                    pollTimeoutId = null;
                }

                // Send destroy request via WebSocket
                ws.send(JSON.stringify({
                    type: 'destroy_stream',
                    streamId: currentStreamId
                }));

                // Also call API as backup
                await apiCall(`/streams/${currentStreamId}`, {
                    method: 'DELETE'
                });
                
                log(`Stream ${currentStreamId} destroy request sent`, 'success');
                
                hideTorrentStats();
                currentStreamId = null;
                currentStream = null;
                videoPlayer.src = '';
                
                createStreamBtn.disabled = false;
                destroyStreamBtn.disabled = true;
                
                streamInfo.classList.remove('visible');
                updateStatus(true, 'Connected to server');
                
            } catch (error) {
                log(`Failed to destroy stream: ${error.message}`, 'error');
            }
        }

        // Fallback polling (only as backup, much less frequent)
        async function fallbackPoll() {
            if (!currentStreamId) return;

            try {
                log('Fallback API poll for stream status', 'info');
                const stream = await apiCall(`/streams/${currentStreamId}`);
                
                updateStreamInfo(stream);
                
                if (stream.status === 'ready' && stream.metadata.filename) {
                    log(`Stream ready via fallback poll! File: ${stream.metadata.filename}`, 'success');
                    startVideoPlayback();
                    updateStatus(true, 'Stream ready');
                    return; // Stop polling
                } else if (stream.status === 'error') {
                    log(`Stream error via fallback poll: ${stream.error || 'Unknown error'}`, 'error');
                    updateStatus(true, 'Stream failed');
                    return; // Stop polling
                }
                
                // Continue fallback polling every 10 seconds (much less frequent)
                pollTimeoutId = setTimeout(fallbackPoll, 10000);
                
            } catch (error) {
                log(`Fallback poll failed: ${error.message}`, 'error');
                // Continue trying with longer delay
                pollTimeoutId = setTimeout(fallbackPoll, 15000);
            }
        }

        // Update stream info display
        function updateStreamInfo(stream) {
            document.getElementById('currentStreamId').textContent = stream.streamId || stream.id;
            document.getElementById('streamStatus').textContent = stream.status;
            document.getElementById('streamFilename').textContent = stream.metadata?.filename || '-';
            document.getElementById('streamFileSize').textContent = 
                stream.metadata?.size ? `${(stream.metadata.size / 1024 / 1024).toFixed(2)} MB` : '-';
            
            streamInfo.classList.add('visible');
        }

        // Start video playback
        function startVideoPlayback() {
            if (!currentStreamId) return;
            
            const streamUrl = `/stream/${currentStreamId}`;
            log(`Starting optimized video playback: ${streamUrl}`, 'info');
            
            // Apply network-aware optimizations
            const video = videoPlayer;
            
            // Set quality-based preload
            setStreamingQuality(streamingQuality);
            
            // Add network-specific optimizations
            if (networkStats.connectionType === 'slow-2g' || networkStats.connectionType === '2g') {
                video.preload = 'none';
                log('Slow connection detected: Minimal preloading', 'info');
            }
            
            video.src = streamUrl;
            
            // Enhanced error handling with retry logic
            video.play().catch(e => {
                log(`Playback error: ${e.message}`, 'error');
                
                // Retry with different approach for MKV files
                if (currentStream?.metadata?.container === '.mkv') {
                    log('MKV detected: Retrying with different headers', 'info');
                    setTimeout(() => {
                        video.load();
                        video.play().catch(retryError => {
                            log(`MKV retry failed: ${retryError.message}`, 'error');
                        });
                    }, 2000);
                }
            });
        }

        // Update server stats
        function updateStats(stats) {
            if (stats) {
                document.getElementById('activeStreams').textContent = stats.activeStreams || 0;
                document.getElementById('connectedClients').textContent = stats.connectedClients || 0;
                document.getElementById('uptime').textContent = Math.round((stats.uptime || 0) / 60);
            }
        }

        // Refresh stats manually
        async function refreshStats() {
            try {
                const health = await apiCall('/health');
                updateStats(health.stats);
                log('Stats refreshed', 'success');
            } catch (error) {
                log(`Failed to refresh stats: ${error.message}`, 'error');
            }
        }

        // Enhanced WebSocket connection with comprehensive event handling
        function connectWebSocket() {
            ws = new WebSocket(`ws://${window.location.hostname}:6543`);

            ws.onopen = () => {
                log('WebSocket connection established', 'success');
                updateStatus(true);
            };

            ws.onclose = () => {
                log('WebSocket connection closed. Attempting to reconnect...', 'error');
                updateStatus(false);
                
                // Cancel any ongoing polling
                if (pollTimeoutId) {
                    clearTimeout(pollTimeoutId);
                    pollTimeoutId = null;
                }
                
                setTimeout(connectWebSocket, 3000);
            };

            ws.onerror = (err) => {
                log('WebSocket error occurred', 'error');
                console.error('WebSocket error:', err);
            };

            ws.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    
                    switch (msg.type) {
                        case 'connected':
                            clientId = msg.clientId;
                            log(`Connected with client ID: ${clientId}`, 'success');
                            startNetworkMonitoring(); // Start monitoring when connected
                            break;
                            
                        case 'stream_created':
                            currentStreamId = msg.streamId;
                            log(`Stream created with ID: ${currentStreamId}`, 'success');
                            
                            updateStreamInfo({
                                streamId: currentStreamId,
                                status: 'initializing',
                                metadata: {}
                            });
                            
                            destroyStreamBtn.disabled = false;
                            updateStatus(true, 'Stream initializing...');
                            
                            // Show torrent monitoring
                            document.getElementById('torrentStats').style.display = 'grid';
                            document.getElementById('torrentProgressBar').style.display = 'block';
                            
                            // Start light fallback polling as backup
                            pollTimeoutId = setTimeout(fallbackPoll, 15000);
                            break;
                            
                        case 'stream_ready':
                            log(`üéâ Stream ready notification: ${JSON.stringify(msg.data)}`, 'success');
                            
                            if (pollTimeoutId) {
                                clearTimeout(pollTimeoutId);
                                pollTimeoutId = null;
                            }
                            
                            if (msg.streamId === currentStreamId) {
                                updateStreamInfo({
                                    streamId: msg.streamId,
                                    status: 'ready',
                                    metadata: msg.data
                                });
                                startVideoPlayback();
                                updateStatus(true, 'Stream ready - Playing video');
                            }
                            break;
                            
                        case 'torrent_stats':
                            // Handle real-time torrent statistics
                            updateTorrentStats(msg.data);
                            break;
                            
                        case 'download_progress':
                            // Handle download progress updates
                            if (msg.data) {
                                const { downloaded, speed } = msg.data;
                                networkStats.totalDownloaded = Math.round(downloaded / 1024 / 1024);
                                networkStats.downloadSpeed = Math.round(speed / 1024);
                                
                                document.getElementById('totalDownloaded').textContent = networkStats.totalDownloaded;
                                document.getElementById('downloadSpeed').textContent = networkStats.downloadSpeed;
                            }
                            break;
                            
                        case 'stream_error':
                            log(`‚ùå Stream error notification: ${msg.data?.error}`, 'error');
                            
                            if (pollTimeoutId) {
                                clearTimeout(pollTimeoutId);
                                pollTimeoutId = null;
                            }
                            
                            if (msg.streamId === currentStreamId) {
                                updateStreamInfo({
                                    streamId: msg.streamId,
                                    status: 'error',
                                    metadata: { error: msg.data?.error }
                                });
                                updateStatus(true, 'Stream failed');
                            }
                            break;
                            
                        case 'stream_destroyed':
                            log(`üóëÔ∏è Stream destroyed notification: ${msg.streamId}`, 'info');
                            
                            if (msg.streamId === currentStreamId) {
                                hideTorrentStats();
                                currentStreamId = null;
                                currentStream = null;
                                videoPlayer.src = '';
                                streamInfo.classList.remove('visible');
                                createStreamBtn.disabled = false;
                                destroyStreamBtn.disabled = true;
                                updateStatus(true, 'Connected to server');
                            }
                            break;
                            
                        case 'pong':
                            // Handle ping/pong for connection health
                            break;
                            
                        default:
                            log(`Unknown WebSocket message: ${msg.type}`, 'info');
                    }
                } catch (e) {
                    log('Error parsing WebSocket message', 'error');
                    console.error('WebSocket parse error:', e);
                }
            };
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            log('Initializing WebSocket-First Video Streamer with Network Monitoring');
            setupVideoPlayerMonitoring();
            connectWebSocket();
            
            // Auto-refresh stats every 30 seconds
            setInterval(refreshStats, 30000);
            
            // Set default quality
            setStreamingQuality('auto');
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (networkMonitorInterval) {
                clearInterval(networkMonitorInterval);
            }
            
            if (currentStreamId) {
                // Quick cleanup via WebSocket
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'destroy_stream',
                        streamId: currentStreamId
                    }));
                }
            }
        });

        // Update torrent statistics display
        function updateTorrentStats(stats) {
            torrentStats = stats;
            
            // Update basic stats
            document.getElementById('torrentPeers').textContent = stats.peers || 0;
            document.getElementById('torrentSeeders').textContent = stats.seeders || 0;
            document.getElementById('torrentLeechers').textContent = stats.leechers || 0;
            
            // Update speeds with formatting
            document.getElementById('torrentDownSpeed').textContent = stats.bandwidth?.downloadSpeedFormatted || '0 B/s';
            document.getElementById('torrentUpSpeed').textContent = stats.bandwidth?.uploadSpeedFormatted || '0 B/s';
            
            // Update progress
            const progress = stats.progress || 0;
            document.getElementById('torrentProgress').textContent = `${progress.toFixed(1)}%`;
            
            // Update progress bar
            const progressFill = document.getElementById('torrentProgressFill');
            progressFill.style.width = `${progress}%`;
            progressFill.textContent = `${progress.toFixed(1)}%`;
            
            // Update health with styling
            const health = stats.health || 'unknown';
            const healthElement = document.getElementById('torrentHealth');
            const healthItem = document.getElementById('torrentHealthItem');
            
            healthElement.textContent = health.charAt(0).toUpperCase() + health.slice(1);
            
            // Remove all health classes
            healthItem.classList.remove('health-excellent', 'health-good', 'health-fair', 'health-poor', 'health-critical');
            healthItem.classList.add(`health-${health}`);
            
            // Update ETA
            const eta = stats.eta || 0;
            document.getElementById('torrentETA').textContent = eta > 0 ? formatTime(eta) : '‚àû';
            
            // Update ratio
            document.getElementById('torrentRatio').textContent = (stats.ratio || 0).toFixed(2);
            
            // Log interesting events
            if (stats.peers !== torrentStats.peers) {
                log(`Peer count changed: ${stats.peers} (${stats.seeders}S/${stats.leechers}L)`, 'info');
            }
            
            if (stats.health !== torrentStats.health) {
                log(`Torrent health changed: ${stats.health}`, 'info');
            }
        }

        // Helper function to format time
        function formatTime(seconds) {
            if (seconds < 60) return `${Math.round(seconds)}s`;
            if (seconds < 3600) return `${Math.round(seconds / 60)}m`;
            if (seconds < 86400) return `${Math.round(seconds / 3600)}h`;
            return `${Math.round(seconds / 86400)}d`;
        }

        // Hide torrent stats when no active stream
        function hideTorrentStats() {
            document.getElementById('torrentStats').style.display = 'none';
            document.getElementById('torrentProgressBar').style.display = 'none';
        }

        // Enhanced destroy function
        async function destroyCurrentStream() {
            if (!currentStreamId) {
                log('No active stream to destroy', 'error');
                return;
            }

            try {
                // Cancel any ongoing polling
                if (pollTimeoutId) {
                    clearTimeout(pollTimeoutId);
                    pollTimeoutId = null;
                }

                // Send destroy request via WebSocket
                ws.send(JSON.stringify({
                    type: 'destroy_stream',
                    streamId: currentStreamId
                }));

                // Also call API as backup
                await apiCall(`/streams/${currentStreamId}`, {
                    method: 'DELETE'
                });
                
                log(`Stream ${currentStreamId} destroy request sent`, 'success');
                
                hideTorrentStats();
                currentStreamId = null;
                currentStream = null;
                videoPlayer.src = '';
                
                createStreamBtn.disabled = false;
                destroyStreamBtn.disabled = true;
                
                streamInfo.classList.remove('visible');
                updateStatus(true, 'Connected to server');
                
            } catch (error) {
                log(`Failed to destroy stream: ${error.message}`, 'error');
            }
        }

        // --- Enhanced Video Streaming Endpoint with Server-Side Activity Tracking ---
        app.get('/stream/:streamId', (req, res) => {
            const { streamId } = req.params;
            const stream = streamManager.getStream(streamId); // This tracks access automatically

            if (!stream || stream.status !== 'ready' || !stream.videoFile) {
                return res.status(404).json({
                    error: 'Stream not ready or not found'
                });
            }

            // Mark as actively streaming
            streamManager.markVideoStreamingActive(streamId);

            const videoFile = stream.videoFile;
            const fileSize = videoFile.length;
            const rangeHeader = req.headers.range;
            const extension = path.extname(videoFile.name).toLowerCase();
            
            console.log(`üì∫ [${streamId}] Video streaming active - server tracking`);

            // ... existing streaming logic ...

            // Track when streaming session ends
            res.on('finish', () => {
                console.log(`üì∫ [${streamId}] Streaming session finished`);
                // Give 5 minute grace period in case user is just pausing/seeking
                streamManager.markVideoStreamingInactive(streamId, 300000);
            });

            res.on('close', () => {
                console.log(`üì∫ [${streamId}] Streaming connection closed`);
                // Shorter grace period for closed connections
                streamManager.markVideoStreamingInactive(streamId, 180000); // 3 minutes
            });

            res.on('error', (err) => {
                console.error(`‚ùå [${streamId}] Streaming error:`, err.message);
                streamManager.markVideoStreamingInactive(streamId, 60000); // 1 minute on error
            });

            // ... rest of your existing streaming code ...
        });

        // --- Enhanced WebSocket with Server-Side Connection Tracking ---
        wss.on('connection', (ws, req) => {
            const clientId = uuidv4();
            ws.clientId = clientId;
            
            console.log(`üîå Client connected: ${clientId} from ${req.socket.remoteAddress}`);
            
            // Track connection server-side
            streamManager.addClientConnection(clientId, ws);
            
            ws.send(JSON.stringify({
                type: 'connected',
                clientId,
                timestamp: Date.now(),
                serverControlled: true // Indicate server handles everything
            }));

            // Ping mechanism to detect client activity
            const pingInterval = setInterval(() => {
                if (ws.readyState === ws.OPEN) {
                    ws.ping();
                    streamManager.updateClientActivity(clientId);
                } else {
                    clearInterval(pingInterval);
                }
            }, 30000); // Ping every 30 seconds

            ws.on('pong', () => {
                streamManager.updateClientActivity(clientId);
            });

            ws.on('message', (message) => {
                streamManager.updateClientActivity(clientId); // Track any message as activity
                
                try {
                    const data = JSON.parse(message);
                    console.log(`üì® WebSocket message from ${clientId}:`, data.type);
                    
                    switch (data.type) {
                        case 'create_stream':
                            handleCreateStreamWS(data, ws, clientId);
                            break;
                            
                        case 'destroy_stream':
                            handleDestroyStreamWS(data, ws, clientId);
                            break;
                            
                        case 'activity_ping':
                            // Client can send this to indicate it's still active
                            streamManager.updateClientActivity(clientId);
                            ws.send(JSON.stringify({
                                type: 'activity_pong',
                                timestamp: Date.now()
                            }));
                            break;
                            
                        case 'ping':
                            ws.send(JSON.stringify({
                                type: 'pong',
                                timestamp: Date.now()
                            }));
                            break;
                            
                        default:
                            console.log(`‚ùì Unknown WebSocket message type: ${data.type}`);
                    }
                } catch (e) {
                    console.error('Invalid WebSocket message:', e.message);
                }
            });

            ws.on('close', () => {
                console.log(`üîå Client disconnected: ${clientId}`);
                clearInterval(pingInterval);
                
                // Cleanup streams and connection tracking
                const destroyed = streamManager.destroyClientStreams(clientId);
                streamManager.removeClientConnection(clientId);
                
                if (destroyed > 0) {
                    console.log(`üßπ Cleaned up ${destroyed} streams for disconnected client ${clientId}`);
                }
            });

            ws.on('error', (err) => {
                console.error(`WebSocket error for ${clientId}:`, err.message);
                clearInterval(pingInterval);
                streamManager.removeClientConnection(clientId);
            });
        });
    </script>
</body>
</html>