<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Video Torrent Stream via WebSocket</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    #status {
      background: #f0f0f0;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
    }
    #fileInfo {
      background: #e8f5e8;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
      display: none;
    }
    #error {
      background: #ffe8e8;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
      display: none;
    }
    .stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin: 10px 0;
    }
    .stat-box {
      background: #f8f8f8;
      padding: 10px;
      border-radius: 5px;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Video Torrent Streaming (MP4/MKV only)</h1>
  <div id="status">Connecting to WebSocket server...</div>
  <div id="fileInfo"></div>
  <div id="error"></div>
  
  <div class="stats">
    <div class="stat-box">
      <strong>Bytes Received</strong><br>
      <span id="totalBytes">0</span>
    </div>
    <div class="stat-box">
      <strong>Chunks Received</strong><br>
      <span id="chunkCount">0</span>
    </div>
  </div>

  <div style="margin: 20px 0;">
    <button id="testVideoBtn" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">
      üé¨ Test Video Player (Demo Mode)
    </button>
    <small style="display: block; margin-top: 5px; color: #666;">
      Click to test the video player with a sample video file
    </small>
  </div>

  <div id="videoContainer" style="margin: 20px 0; display: none;">
    <h3>Video Player</h3>
    <video id="videoPlayer" controls width="100%" style="max-width: 800px; background: #000;" preload="none">
      Your browser does not support the video tag.
    </video>
    <div id="playbackInfo" style="margin-top: 10px; font-size: 12px; color: #666;">
      Buffering video data...
    </div>
    <div id="videoControls" style="margin-top: 10px;">
      <button id="playBtn" style="margin-right: 10px;">‚ñ∂Ô∏è Play</button>
      <button id="pauseBtn" style="margin-right: 10px;">‚è∏Ô∏è Pause</button>
      <span id="timeDisplay" style="margin-left: 10px; font-family: monospace;">0:00 / 0:00</span>
    </div>
  </div>

  <script>
    const statusDiv = document.getElementById('status');
    const fileInfoDiv = document.getElementById('fileInfo');
    const errorDiv = document.getElementById('error');
    const totalBytesSpan = document.getElementById('totalBytes');
    const chunkCountSpan = document.getElementById('chunkCount');
    const videoContainer = document.getElementById('videoContainer');
    const videoPlayer = document.getElementById('videoPlayer');
    const playbackInfo = document.getElementById('playbackInfo');
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const timeDisplay = document.getElementById('timeDisplay');
    const testVideoBtn = document.getElementById('testVideoBtn');
    
    const ws = new WebSocket('ws://localhost:3001');

    // Accumulate received bytes count
    let totalBytes = 0;
    let chunkCount = 0;
    let currentFile = null;
    
    // Video streaming variables
    let mediaSource = null;
    let sourceBuffer = null;
    let chunks = [];
    let isAppending = false;
    let mimeType = '';

    // Initialize MediaSource for video playback
    function initializeMediaSource(fileName) {
      // Determine MIME type based on file extension
      const extension = fileName.toLowerCase().split('.').pop();
      if (extension === 'mp4') {
        mimeType = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
      } else if (extension === 'mkv') {
        // Try WebM first, then fallback to MP4
        mimeType = 'video/webm; codecs="vp9, opus"';
        if (!MediaSource.isTypeSupported(mimeType)) {
          mimeType = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
        }
      } else {
        mimeType = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"'; // Default fallback
      }
      
      if (!MediaSource.isTypeSupported(mimeType)) {
        console.warn('MIME type not supported:', mimeType);
        playbackInfo.textContent = 'Video format may not be directly playable. Trying generic MP4...';
        mimeType = 'video/mp4'; // Minimal fallback
      }
      
      mediaSource = new MediaSource();
      videoPlayer.src = URL.createObjectURL(mediaSource);
      
      mediaSource.addEventListener('sourceopen', () => {
        console.log('MediaSource opened with MIME type:', mimeType);
        try {
          sourceBuffer = mediaSource.addSourceBuffer(mimeType);
          sourceBuffer.addEventListener('updateend', onSourceBufferUpdateEnd);
          sourceBuffer.addEventListener('error', (e) => {
            console.error('SourceBuffer error:', e);
            playbackInfo.textContent = 'Error: Video format not compatible with browser';
          });
          
          playbackInfo.textContent = 'Ready to play video. Buffering...';
          videoContainer.style.display = 'block';
          setupVideoControls();
        } catch (e) {
          console.error('Error creating SourceBuffer:', e);
          playbackInfo.textContent = 'Error: Cannot create video buffer. Format may not be supported.';
        }
      });
      
      mediaSource.addEventListener('sourceended', () => {
        console.log('MediaSource ended');
      });
      
      mediaSource.addEventListener('error', (e) => {
        console.error('MediaSource error:', e);
        playbackInfo.textContent = 'MediaSource error occurred';
      });
    }
    
    function setupVideoControls() {
      // Custom play button
      playBtn.addEventListener('click', () => {
        videoPlayer.play().then(() => {
          console.log('Video started playing');
        }).catch(e => {
          console.error('Play failed:', e);
          playbackInfo.textContent = 'Play failed: ' + e.message;
        });
      });
      
      // Custom pause button
      pauseBtn.addEventListener('click', () => {
        videoPlayer.pause();
        console.log('Video paused');
      });
      
      // Time update handler
      videoPlayer.addEventListener('timeupdate', () => {
        const current = formatTime(videoPlayer.currentTime);
        const duration = formatTime(videoPlayer.duration || 0);
        timeDisplay.textContent = `${current} / ${duration}`;
      });
      
      // Video event listeners
      videoPlayer.addEventListener('loadstart', () => {
        console.log('Video load start');
        playbackInfo.textContent = 'Loading video...';
      });
      
      videoPlayer.addEventListener('canplay', () => {
        console.log('Video can play');
        playbackInfo.textContent = 'Video ready to play';
      });
      
      videoPlayer.addEventListener('playing', () => {
        console.log('Video playing');
        playbackInfo.textContent = 'Video playing';
      });
      
      videoPlayer.addEventListener('waiting', () => {
        console.log('Video waiting/buffering');
        playbackInfo.textContent = 'Buffering...';
      });
      
      videoPlayer.addEventListener('error', (e) => {
        console.error('Video error:', e);
        playbackInfo.textContent = 'Video playback error';
      });
    }
    
    function formatTime(seconds) {
      if (isNaN(seconds)) return '0:00';
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    function onSourceBufferUpdateEnd() {
      isAppending = false;
      
      // Append next chunk if available
      if (chunks.length > 0 && !sourceBuffer.updating) {
        appendNextChunk();
      }
      
      // Update playback info
      if (videoPlayer.buffered.length > 0) {
        const bufferedEnd = videoPlayer.buffered.end(videoPlayer.buffered.length - 1);
        const duration = videoPlayer.duration || 0;
        const bufferedMB = (bufferedEnd * 1000).toFixed(1); // Rough estimate
        playbackInfo.textContent = `Buffered: ${bufferedEnd.toFixed(1)}s${duration ? ` / ${duration.toFixed(1)}s` : ''} (~${bufferedMB}KB)`;
        
        // Auto-play when enough data is buffered (3 seconds)
        if (bufferedEnd > 3 && videoPlayer.paused && videoPlayer.readyState >= 3) {
          videoPlayer.play().then(() => {
            console.log('Auto-play started');
            playbackInfo.textContent += ' - Auto-playing';
          }).catch(e => {
            console.log('Auto-play failed (user interaction required):', e.message);
            playbackInfo.textContent += ' (Click play to start)';
          });
        }
      }
    }
    
    function appendNextChunk() {
      if (chunks.length > 0 && sourceBuffer && !sourceBuffer.updating && !isAppending) {
        isAppending = true;
        const chunk = chunks.shift();
        try {
          sourceBuffer.appendBuffer(chunk);
        } catch (e) {
          console.error('Error appending buffer:', e);
          isAppending = false;
          playbackInfo.textContent = 'Error appending video data';
        }
      }
    }
    
    function addVideoChunk(chunkData) {
      // chunkData is already a Uint8Array from ArrayBuffer
      chunks.push(chunkData);
      
      // Start appending if not already doing so
      if (sourceBuffer && !isAppending) {
        appendNextChunk();
      }
    }

    ws.onopen = () => {
      statusDiv.textContent = 'Connected to WebSocket server. Waiting for video files...';
      console.log('WebSocket connection opened.');
    };

    // Test video player functionality
    testVideoBtn.addEventListener('click', () => {
      // Simulate receiving file info for demo
      const demoFile = {
        name: 'sample_video.mp4',
        size: 50000000, // 50MB demo size
        totalFiles: 1
      };
      
      currentFile = demoFile;
      fileInfoDiv.innerHTML = `
        <strong>Demo Mode:</strong> ${demoFile.name}<br>
        <strong>File Size:</strong> ${formatBytes(demoFile.size)}<br>
        <strong>Video Files Found:</strong> ${demoFile.totalFiles}
      `;
      fileInfoDiv.style.display = 'block';
      statusDiv.textContent = 'Demo mode: Video player ready';
      
      // Initialize video player for demo
      initializeMediaSource(demoFile.name);
      
      // Use a sample video URL for testing (Big Buck Bunny - Creative Commons)
      videoPlayer.src = 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4';
      videoContainer.style.display = 'block';
      playbackInfo.textContent = 'Demo video loaded - click play to test';
      setupVideoControls();
    });

    ws.onmessage = (event) => {
      // Handle both binary chunks and JSON messages
      if (event.data instanceof ArrayBuffer) {
        // Binary chunk received
        const chunkSize = event.data.byteLength;
        totalBytes += chunkSize;
        chunkCount++;
        
        totalBytesSpan.textContent = formatBytes(totalBytes);
        chunkCountSpan.textContent = chunkCount.toLocaleString();
        
        if (currentFile) {
          const progress = ((totalBytes / currentFile.size) * 100).toFixed(1);
          statusDiv.textContent = `Streaming: ${progress}% (${formatBytes(totalBytes)} / ${formatBytes(currentFile.size)})`;
        }
        
        console.log(`Received binary chunk: ${chunkSize} bytes`);
        
        // Add chunk to video player
        if (mediaSource && mediaSource.readyState === 'open') {
          addVideoChunk(new Uint8Array(event.data));
        }
        return;
      }
      
      // JSON message received
      try {
        const message = JSON.parse(event.data);
        
        switch(message.type) {
          case 'connected':
            statusDiv.textContent = message.message;
            break;
            
          case 'fileInfo':
            currentFile = message;
            fileInfoDiv.innerHTML = `
              <strong>Streaming:</strong> ${message.name}<br>
              <strong>File Size:</strong> ${formatBytes(message.size)}<br>
              <strong>Video Files Found:</strong> ${message.totalFiles}
            `;
            fileInfoDiv.style.display = 'block';
            statusDiv.textContent = 'Streaming video file...';
            
            // Initialize video player for this file
            initializeMediaSource(message.name);
            break;
            
          case 'streamEnd':
            statusDiv.textContent = message.message;
            console.log('Stream ended:', message.message);
            
            // End the media source
            if (mediaSource && mediaSource.readyState === 'open') {
              try {
                if (sourceBuffer && !sourceBuffer.updating) {
                  mediaSource.endOfStream();
                  playbackInfo.textContent = 'Video stream complete';
                }
              } catch (e) {
                console.error('Error ending stream:', e);
              }
            }
            break;
            
          case 'streamError':
            errorDiv.textContent = message.message;
            errorDiv.style.display = 'block';
            console.error('Stream error:', message.message);
            break;
            
          case 'error':
            errorDiv.textContent = message.message;
            errorDiv.style.display = 'block';
            statusDiv.textContent = 'No video files found in torrent';
            console.error('Error:', message.message);
            break;
            
          default:
            console.log('Unknown message type:', message.type);
        }
      } catch (err) {
        console.error('Error parsing message:', err);
      }
    };

    // Set binary type for WebSocket to receive ArrayBuffer
    ws.binaryType = 'arraybuffer';

    ws.onerror = (error) => {
      statusDiv.textContent = 'WebSocket error! Server may not be running.';
      errorDiv.innerHTML = `
        <strong>Connection Error:</strong><br>
        Make sure the WebSocket server is running on port 3001<br>
        <small>Run: <code>node index.js</code> in the controller folder</small>
      `;
      errorDiv.style.display = 'block';
      console.error('WebSocket error:', error);
    };

    ws.onclose = () => {
      statusDiv.textContent = 'WebSocket connection closed. You can still test the video player in demo mode.';
      console.log('WebSocket connection closed.');
    };
    
    // Helper function to format bytes
    function formatBytes(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
  </script>
</body>
</html>
