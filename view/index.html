<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Video Torrent Stream via WebSocket</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    #status {
      background: #f0f0f0;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
    }
    #fileInfo {
      background: #e8f5e8;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
      display: none;
    }
    #error {
      background: #ffe8e8;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
      display: none;
    }
    .stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin: 10px 0;
    }
    .stat-box {
      background: #f8f8f8;
      padding: 10px;
      border-radius: 5px;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Video Torrent Streaming (MP4/MKV only)</h1>
  <div id="status">Connecting to WebSocket server...</div>
  <div id="fileInfo"></div>
  <div id="error"></div>
  
  <div class="stats">
    <div class="stat-box">
      <strong>Bytes Received</strong><br>
      <span id="totalBytes">0</span>
    </div>
    <div class="stat-box">
      <strong>Chunks Received</strong><br>
      <span id="chunkCount">0</span>
    </div>
  </div>

  <div style="margin: 20px 0;">
    <button id="testVideoBtn" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">
      üé¨ Enable Video Player (for WebSocket chunks)
    </button>
    <small style="display: block; margin-top: 5px; color: #666;">
      Click to prepare video player for streaming chunks from WebSocket
    </small>
  </div>

  <div id="videoContainer" style="margin: 20px 0; display: none;">
    <h3>Video Player</h3>
    <video id="videoPlayer" controls width="100%" style="max-width: 800px; background: #000;" preload="none">
      Your browser does not support the video tag.
    </video>
    <div id="playbackInfo" style="margin-top: 10px; font-size: 12px; color: #666;">
      Buffering video data...
    </div>
    <div id="videoControls" style="margin-top: 10px;">
      <button id="playBtn" style="margin-right: 10px;">‚ñ∂Ô∏è Play</button>
      <button id="pauseBtn" style="margin-right: 10px;">‚è∏Ô∏è Pause</button>
      <span id="timeDisplay" style="margin-left: 10px; font-family: monospace;">0:00 / 0:00</span>
    </div>
  </div>

  <script>
    const statusDiv = document.getElementById('status');
    const fileInfoDiv = document.getElementById('fileInfo');
    const errorDiv = document.getElementById('error');
    const totalBytesSpan = document.getElementById('totalBytes');
    const chunkCountSpan = document.getElementById('chunkCount');
    const videoContainer = document.getElementById('videoContainer');
    const videoPlayer = document.getElementById('videoPlayer');
    const playbackInfo = document.getElementById('playbackInfo');
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const timeDisplay = document.getElementById('timeDisplay');
    const testVideoBtn = document.getElementById('testVideoBtn');
    
    const ws = new WebSocket('ws://localhost:3001');

    // Accumulate received bytes count
    let totalBytes = 0;
    let chunkCount = 0;
    let currentFile = null;
    
    // Video streaming variables
    let mediaSource = null;
    let sourceBuffer = null;
    let chunks = [];
    let isAppending = false;
    let mimeType = '';

    // Initialize MediaSource for video playbook
    function initializeMediaSource(fileName) {
      // Test different codec combinations for better compatibility
      // H.265 (HEVC) has limited browser support, prioritize H.264
      const possibleMimeTypes = [
        'video/mp4; codecs="avc1.42E01E, mp4a.40.2"',  // H.264 Baseline
        'video/mp4; codecs="avc1.4D401E, mp4a.40.2"',  // H.264 Main
        'video/mp4; codecs="avc1.64001E, mp4a.40.2"',  // H.264 High
        'video/mp4; codecs="avc1.640028, mp4a.40.2"',  // H.264 High Level 4.0
        'video/mp4; codecs="avc1.42E01E"',              // H.264 only
        'video/mp4; codecs="avc1.4D001E"',              // H.264 Main only
        'video/mp4',                                     // Generic MP4
        'video/webm; codecs="vp9, opus"',               // VP9 fallback
        'video/webm; codecs="vp8, vorbis"',             // VP8 fallback
        'video/webm'                                     // Generic WebM
      ];
      
      // Find the first supported MIME type
      mimeType = possibleMimeTypes.find(type => MediaSource.isTypeSupported(type));
      
      if (!mimeType) {
        console.error('No supported video formats found');
        playbackInfo.textContent = 'Error: Browser does not support any video formats. This video may use H.265/HEVC codec which is not supported by MediaSource API.';
        
        // Show alternative options
        const alternativeInfo = document.createElement('div');
        alternativeInfo.innerHTML = `
          <h4>Alternative Options:</h4>
          <p>1. This video uses H.265/HEVC codec which browsers don't support for streaming</p>
          <p>2. Try with an H.264 encoded video torrent instead</p>
          <p>3. The WebSocket chunks are being received successfully - the issue is browser codec support</p>
        `;
        alternativeInfo.style.background = '#fff3cd';
        alternativeInfo.style.padding = '10px';
        alternativeInfo.style.borderRadius = '5px';
        alternativeInfo.style.marginTop = '10px';
        alternativeInfo.style.fontSize = '14px';
        videoContainer.appendChild(alternativeInfo);
        
        return;
      }
      
      console.log('Using MIME type:', mimeType);
      
      mediaSource = new MediaSource();
      videoPlayer.src = URL.createObjectURL(mediaSource);
      
      mediaSource.addEventListener('sourceopen', () => {
        console.log('MediaSource opened with MIME type:', mimeType);
        try {
          sourceBuffer = mediaSource.addSourceBuffer(mimeType);
          sourceBuffer.addEventListener('updateend', onSourceBufferUpdateEnd);
          sourceBuffer.addEventListener('error', (e) => {
            console.error('SourceBuffer error:', e);
            playbackInfo.textContent = 'Error: Video format not compatible with browser';
          });
          
          playbackInfo.textContent = 'Ready to receive video chunks from WebSocket...';
          videoContainer.style.display = 'block';
          setupVideoControls();
          
          // Process any chunks that arrived before MediaSource was ready
          if (chunks.length > 0) {
            console.log(`Processing ${chunks.length} queued chunks`);
            processQueuedChunks();
          }
        } catch (e) {
          console.error('Error creating SourceBuffer:', e);
          playbackInfo.textContent = 'Error: Cannot create video buffer. Trying alternative format...';
          // Try with a more basic MIME type
          tryFallbackMediaSource();
        }
      });
      
      mediaSource.addEventListener('sourceended', () => {
        console.log('MediaSource ended');
      });
      
      mediaSource.addEventListener('error', (e) => {
        console.error('MediaSource error:', e);
        playbackInfo.textContent = 'MediaSource error occurred';
      });
    }
    
    function tryFallbackMediaSource() {
      console.log('Trying fallback MediaSource with basic MP4');
      if (mediaSource && mediaSource.readyState === 'open') {
        try {
          sourceBuffer = mediaSource.addSourceBuffer('video/mp4');
          sourceBuffer.addEventListener('updateend', onSourceBufferUpdateEnd);
          sourceBuffer.addEventListener('error', (e) => {
            console.error('Fallback SourceBuffer error:', e);
            playbackInfo.textContent = 'Error: Video format not supported by browser';
          });
          playbackInfo.textContent = 'Using fallback video format...';
          if (chunks.length > 0) {
            processQueuedChunks();
          }
        } catch (e) {
          console.error('Fallback MediaSource also failed:', e);
          playbackInfo.textContent = 'Error: Browser cannot play this video format';
        }
      }
    }
    
    function processQueuedChunks() {
      console.log(`Processing ${chunks.length} queued chunks`);
      // Process chunks one by one to avoid overwhelming the buffer
      if (chunks.length > 0 && sourceBuffer && !sourceBuffer.updating) {
        appendNextChunk();
      }
    }
    
    function setupVideoControls() {
      // Custom play button
      playBtn.addEventListener('click', () => {
        // Check if video has enough data buffered
        if (videoPlayer.buffered.length === 0) {
          playbackInfo.textContent = 'Waiting for video data to buffer...';
          return;
        }
        
        const bufferedEnd = videoPlayer.buffered.end(0);
        if (bufferedEnd < 2) {
          playbackInfo.textContent = 'Buffering more data before play... (' + bufferedEnd.toFixed(1) + 's buffered)';
          return;
        }
        
        videoPlayer.play().then(() => {
          console.log('Video started playing');
          playbackInfo.textContent = 'Video playing successfully';
        }).catch(e => {
          console.error('Play failed:', e);
          playbackInfo.textContent = 'Play failed: ' + e.message + ' (Try waiting for more data)';
        });
      });
      
      // Custom pause button
      pauseBtn.addEventListener('click', () => {
        videoPlayer.pause();
        console.log('Video paused');
      });
      
      // Time update handler
      videoPlayer.addEventListener('timeupdate', () => {
        const current = formatTime(videoPlayer.currentTime);
        const duration = formatTime(videoPlayer.duration || 0);
        timeDisplay.textContent = `${current} / ${duration}`;
      });
      
      // Video event listeners
      videoPlayer.addEventListener('loadstart', () => {
        console.log('Video load start');
        playbackInfo.textContent = 'Loading video...';
      });
      
      videoPlayer.addEventListener('canplay', () => {
        console.log('Video can play');
        playbackInfo.textContent = 'Video ready to play';
      });
      
      videoPlayer.addEventListener('playing', () => {
        console.log('Video playing');
        playbackInfo.textContent = 'Video playing';
      });
      
      videoPlayer.addEventListener('waiting', () => {
        console.log('Video waiting/buffering');
        playbackInfo.textContent = 'Buffering...';
      });
      
      videoPlayer.addEventListener('error', (e) => {
        console.error('Video error:', e);
        playbackInfo.textContent = 'Video playback error';
      });
    }
    
    function formatTime(seconds) {
      if (isNaN(seconds)) return '0:00';
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    function onSourceBufferUpdateEnd() {
      isAppending = false;
      
      // Append next chunk if available
      if (chunks.length > 0 && !sourceBuffer.updating) {
        appendNextChunk();
      }
      
      // Update playback info
      if (videoPlayer.buffered.length > 0) {
        const bufferedEnd = videoPlayer.buffered.end(videoPlayer.buffered.length - 1);
        const duration = videoPlayer.duration || 0;
        const bufferedMB = (bufferedEnd * 1000).toFixed(1); // Rough estimate
        playbackInfo.textContent = `Buffered: ${bufferedEnd.toFixed(1)}s${duration ? ` / ${duration.toFixed(1)}s` : ''} (~${bufferedMB}KB)`;
        
        // Auto-play when enough data is buffered (5 seconds) and user has interacted
        if (bufferedEnd > 5 && videoPlayer.paused && videoPlayer.readyState >= 3) {
          // Don't auto-play immediately, wait for user interaction
          playbackInfo.textContent += ' - Ready to play (click play button)';
        }
      }
    }
    
    function appendNextChunk() {
      if (chunks.length > 0 && sourceBuffer && !sourceBuffer.updating && !isAppending) {
        isAppending = true;
        const chunk = chunks.shift();
        console.log(`Appending chunk to video buffer. Size: ${chunk.length} bytes, Remaining: ${chunks.length}`);
        try {
          sourceBuffer.appendBuffer(chunk);
        } catch (e) {
          console.error('Error appending buffer:', e);
          isAppending = false;
          playbackInfo.textContent = 'Error appending video data: ' + e.message;
        }
      }
    }
    
    function addVideoChunk(chunkData) {
      // chunkData is already a Uint8Array from ArrayBuffer
      chunks.push(chunkData);
      
      console.log(`Added video chunk to buffer. Queue size: ${chunks.length}`);
      
      // Start appending if MediaSource and SourceBuffer are ready
      if (sourceBuffer && !isAppending && mediaSource && mediaSource.readyState === 'open') {
        appendNextChunk();
      } else {
        console.log('MediaSource not ready, chunk queued for later (State:', mediaSource?.readyState, ')');
      }
    }

    ws.onopen = () => {
      statusDiv.textContent = 'Connected to WebSocket server. Waiting for video files...';
      console.log('WebSocket connection opened.');
    };

    // Test video player functionality
    testVideoBtn.addEventListener('click', () => {
      // Simulate receiving file info for demo
      const demoFile = {
        name: 'sample_video.mp4',
        size: 50000000, // 50MB demo size
        totalFiles: 1
      };
      
      currentFile = demoFile;
      fileInfoDiv.innerHTML = `
        <strong>Demo Mode:</strong> ${demoFile.name}<br>
        <strong>File Size:</strong> ${formatBytes(demoFile.size)}<br>
        <strong>Video Files Found:</strong> ${demoFile.totalFiles}
      `;
      fileInfoDiv.style.display = 'block';
      statusDiv.textContent = 'Demo mode: Waiting for WebSocket chunks to play video';
      
      // Initialize video player for demo - this will use MediaSource API for chunks
      initializeMediaSource(demoFile.name);
      
      // Hide the demo button since we're now in streaming mode
      testVideoBtn.style.display = 'none';
    });

    ws.onmessage = (event) => {
      // Handle both binary chunks and JSON messages
      if (event.data instanceof ArrayBuffer) {
        // Binary chunk received - this is video data
        const chunkSize = event.data.byteLength;
        totalBytes += chunkSize;
        chunkCount++;
        
        totalBytesSpan.textContent = formatBytes(totalBytes);
        chunkCountSpan.textContent = chunkCount.toLocaleString();
        
        if (currentFile) {
          const progress = ((totalBytes / currentFile.size) * 100).toFixed(1);
          statusDiv.textContent = `Streaming: ${progress}% (${formatBytes(totalBytes)} / ${formatBytes(currentFile.size)})`;
        }
        
        console.log(`Received binary video chunk: ${chunkSize} bytes`);
        
        // Add chunk to video player for playback
        if (mediaSource && mediaSource.readyState === 'open' && sourceBuffer) {
          addVideoChunk(new Uint8Array(event.data));
          playbackInfo.textContent = `Playing video... Chunks: ${chunkCount}, Buffered: ${formatBytes(totalBytes)}`;
        } else {
          console.log('MediaSource not ready, chunk queued (State:', mediaSource?.readyState, ')');
          // Store chunk for later if MediaSource isn't ready yet
          chunks.push(new Uint8Array(event.data));
          if (videoContainer.style.display === 'none') {
            // Auto-initialize video player if we start receiving chunks
            console.log('Auto-initializing video player for incoming chunks');
            initializeMediaSource('stream.mp4'); // Default filename
            videoContainer.style.display = 'block';
          }
        }
        return;
      }
      
      // JSON message received
      try {
        const message = JSON.parse(event.data);
        
        switch(message.type) {
          case 'connected':
            statusDiv.textContent = message.message;
            break;
            
          case 'fileInfo':
            currentFile = message;
            fileInfoDiv.innerHTML = `
              <strong>Streaming:</strong> ${message.name}<br>
              <strong>File Size:</strong> ${formatBytes(message.size)}<br>
              <strong>Video Files Found:</strong> ${message.totalFiles}
            `;
            fileInfoDiv.style.display = 'block';
            statusDiv.textContent = 'Streaming video file...';
            
            // Initialize video player for this file
            initializeMediaSource(message.name);
            break;
            
          case 'streamEnd':
            statusDiv.textContent = message.message;
            console.log('Stream ended:', message.message);
            
            // End the media source
            if (mediaSource && mediaSource.readyState === 'open') {
              try {
                if (sourceBuffer && !sourceBuffer.updating) {
                  mediaSource.endOfStream();
                  playbackInfo.textContent = 'Video stream complete';
                }
              } catch (e) {
                console.error('Error ending stream:', e);
              }
            }
            break;
            
          case 'streamError':
            errorDiv.textContent = message.message;
            errorDiv.style.display = 'block';
            console.error('Stream error:', message.message);
            break;
            
          case 'error':
            errorDiv.textContent = message.message;
            errorDiv.style.display = 'block';
            statusDiv.textContent = 'No video files found in torrent';
            console.error('Error:', message.message);
            break;
            
          default:
            console.log('Unknown message type:', message.type);
        }
      } catch (err) {
        console.error('Error parsing message:', err);
      }
    };

    // Set binary type for WebSocket to receive ArrayBuffer
    ws.binaryType = 'arraybuffer';

    ws.onerror = (error) => {
      statusDiv.textContent = 'WebSocket error! Server may not be running.';
      errorDiv.innerHTML = `
        <strong>Connection Error:</strong><br>
        Make sure the WebSocket server is running on port 3001<br>
        <small>Run: <code>node index.js</code> in the controller folder</small>
      `;
      errorDiv.style.display = 'block';
      console.error('WebSocket error:', error);
    };

    ws.onclose = () => {
      statusDiv.textContent = 'WebSocket connection closed. You can still test the video player in demo mode.';
      console.log('WebSocket connection closed.');
    };
    
    // Helper function to format bytes
    function formatBytes(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
  </script>
</body>
</html>
